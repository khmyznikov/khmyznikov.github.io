{"version":3,"file":"index-d961e0b8.js","sources":["../../node_modules/urlpattern-polyfill/dist/urlpattern.js","../../node_modules/urlpattern-polyfill/index.js"],"sourcesContent":["// src/path-to-regex-modified.ts\nvar regexIdentifierStart = /[$_\\p{ID_Start}]/u;\nvar regexIdentifierPart = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\nfunction isASCII(str, extended) {\n  return (extended ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(str);\n}\nfunction lexer(str, lenient = false) {\n  const tokens = [];\n  let i = 0;\n  while (i < str.length) {\n    const char = str[i];\n    const ErrorOrInvalid = function(msg) {\n      if (!lenient)\n        throw new TypeError(msg);\n      tokens.push({ type: \"INVALID_CHAR\", index: i, value: str[i++] });\n    };\n    if (char === \"*\") {\n      tokens.push({ type: \"ASTERISK\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n      while (j < str.length) {\n        const code = str.substr(j, 1);\n        if (j === i + 1 && regexIdentifierStart.test(code) || j !== i + 1 && regexIdentifierPart.test(code)) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) {\n        ErrorOrInvalid(`Missing parameter name at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n      let error = false;\n      if (str[j] === \"?\") {\n        ErrorOrInvalid(`Pattern cannot start with \"?\" at ${j}`);\n        continue;\n      }\n      while (j < str.length) {\n        if (!isASCII(str[j], false)) {\n          ErrorOrInvalid(`Invalid character '${str[j]}' at ${j}.`);\n          error = true;\n          break;\n        }\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            ErrorOrInvalid(`Capturing groups are not allowed at ${j}`);\n            error = true;\n            break;\n          }\n        }\n        pattern += str[j++];\n      }\n      if (error) {\n        continue;\n      }\n      if (count) {\n        ErrorOrInvalid(`Unbalanced pattern at ${i}`);\n        continue;\n      }\n      if (!pattern) {\n        ErrorOrInvalid(`Missing pattern at ${i}`);\n        continue;\n      }\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n  return tokens;\n}\nfunction parse(str, options = {}) {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter === void 0 ? \"/#?\" : options.delimiter)}]+?`;\n  const result = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n  let nameSet = /* @__PURE__ */ new Set();\n  const tryConsume = (type) => {\n    if (i < tokens.length && tokens[i].type === type)\n      return tokens[i++].value;\n  };\n  const tryConsumeModifier = () => {\n    const r = tryConsume(\"MODIFIER\");\n    if (r) {\n      return r;\n    }\n    return tryConsume(\"ASTERISK\");\n  };\n  const mustConsume = (type) => {\n    const value = tryConsume(type);\n    if (value !== void 0)\n      return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n  const consumeText = () => {\n    let result2 = \"\";\n    let value;\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result2 += value;\n    }\n    return result2;\n  };\n  const DefaultEncodePart = (value) => {\n    return value;\n  };\n  const encodePart = options.encodePart || DefaultEncodePart;\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    let pattern = tryConsume(\"PATTERN\");\n    if (!name && !pattern && tryConsume(\"ASTERISK\")) {\n      pattern = \".*\";\n    }\n    if (name || pattern) {\n      let prefix = char || \"\";\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n      if (path) {\n        result.push(encodePart(path));\n        path = \"\";\n      }\n      const finalName = name || key++;\n      if (nameSet.has(finalName)) {\n        throw new TypeError(`Duplicate name '${finalName}'.`);\n      }\n      nameSet.add(finalName);\n      result.push({\n        name: finalName,\n        prefix: encodePart(prefix),\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsumeModifier() || \"\"\n      });\n      continue;\n    }\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name2 = tryConsume(\"NAME\") || \"\";\n      let pattern2 = tryConsume(\"PATTERN\") || \"\";\n      if (!name2 && !pattern2 && tryConsume(\"ASTERISK\")) {\n        pattern2 = \".*\";\n      }\n      const suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      const modifier = tryConsumeModifier() || \"\";\n      if (!name2 && !pattern2 && !modifier) {\n        path += prefix;\n        continue;\n      }\n      if (!name2 && !pattern2 && !prefix) {\n        continue;\n      }\n      if (path) {\n        result.push(encodePart(path));\n        path = \"\";\n      }\n      result.push({\n        name: name2 || (pattern2 ? key++ : \"\"),\n        pattern: name2 && !pattern2 ? defaultPattern : pattern2,\n        prefix: encodePart(prefix),\n        suffix: encodePart(suffix),\n        modifier\n      });\n      continue;\n    }\n    if (path) {\n      result.push(encodePart(path));\n      path = \"\";\n    }\n    mustConsume(\"END\");\n  }\n  return result;\n}\nfunction escapeString(str) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction flags(options) {\n  return options && options.ignoreCase ? \"ui\" : \"u\";\n}\nfunction regexpToRegexp(path, keys) {\n  if (!keys)\n    return path;\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n  return path;\n}\nfunction arrayToRegexp(paths, keys, options) {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\nfunction tokensToRegexp(tokens, keys, options = {}) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x) => x\n  } = options;\n  const endsWith = `[${escapeString(options.endsWith === void 0 ? \"\" : options.endsWith)}]|$`;\n  const delimiter = `[${escapeString(options.delimiter === void 0 ? \"/#?\" : options.delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n      if (token.pattern) {\n        if (keys)\n          keys.push(token);\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n  if (end) {\n    if (!strict)\n      route += `${delimiter}?`;\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n  return new RegExp(route, flags(options));\n}\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp)\n    return regexpToRegexp(path, keys);\n  if (Array.isArray(path))\n    return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\n// src/url-utils.ts\nvar DEFAULT_OPTIONS = {\n  delimiter: \"\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar HOSTNAME_OPTIONS = {\n  delimiter: \".\",\n  prefixes: \"\",\n  sensitive: true,\n  strict: true\n};\nvar PATHNAME_OPTIONS = {\n  delimiter: \"/\",\n  prefixes: \"/\",\n  sensitive: true,\n  strict: true\n};\nfunction isAbsolutePathname(pathname, isPattern) {\n  if (!pathname.length) {\n    return false;\n  }\n  if (pathname[0] === \"/\") {\n    return true;\n  }\n  if (!isPattern) {\n    return false;\n  }\n  if (pathname.length < 2) {\n    return false;\n  }\n  if ((pathname[0] == \"\\\\\" || pathname[0] == \"{\") && pathname[1] == \"/\") {\n    return true;\n  }\n  return false;\n}\nfunction maybeStripPrefix(value, prefix) {\n  if (value.startsWith(prefix)) {\n    return value.substring(prefix.length, value.length);\n  }\n  return value;\n}\nfunction maybeStripSuffix(value, suffix) {\n  if (value.endsWith(suffix)) {\n    return value.substr(0, value.length - suffix.length);\n  }\n  return value;\n}\nfunction treatAsIPv6Hostname(value) {\n  if (!value || value.length < 2) {\n    return false;\n  }\n  if (value[0] === \"[\") {\n    return true;\n  }\n  if ((value[0] === \"\\\\\" || value[0] === \"{\") && value[1] === \"[\") {\n    return true;\n  }\n  return false;\n}\nvar SPECIAL_SCHEMES = [\n  \"ftp\",\n  \"file\",\n  \"http\",\n  \"https\",\n  \"ws\",\n  \"wss\"\n];\nfunction isSpecialScheme(protocol_regexp) {\n  if (!protocol_regexp) {\n    return true;\n  }\n  for (const scheme of SPECIAL_SCHEMES) {\n    if (protocol_regexp.test(scheme)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction canonicalizeHash(hash, isPattern) {\n  hash = maybeStripPrefix(hash, \"#\");\n  if (isPattern || hash === \"\") {\n    return hash;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = hash;\n  return url.hash ? url.hash.substring(1, url.hash.length) : \"\";\n}\nfunction canonicalizeSearch(search, isPattern) {\n  search = maybeStripPrefix(search, \"?\");\n  if (isPattern || search === \"\") {\n    return search;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.search ? url.search.substring(1, url.search.length) : \"\";\n}\nfunction canonicalizeHostname(hostname, isPattern) {\n  if (isPattern || hostname === \"\") {\n    return hostname;\n  }\n  if (treatAsIPv6Hostname(hostname)) {\n    return ipv6HostnameEncodeCallback(hostname);\n  } else {\n    return hostnameEncodeCallback(hostname);\n  }\n}\nfunction canonicalizePassword(password, isPattern) {\n  if (isPattern || password === \"\") {\n    return password;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = password;\n  return url.password;\n}\nfunction canonicalizeUsername(username, isPattern) {\n  if (isPattern || username === \"\") {\n    return username;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = username;\n  return url.username;\n}\nfunction canonicalizePathname(pathname, protocol, isPattern) {\n  if (isPattern || pathname === \"\") {\n    return pathname;\n  }\n  if (protocol && !SPECIAL_SCHEMES.includes(protocol)) {\n    const url = new URL(`${protocol}:${pathname}`);\n    return url.pathname;\n  }\n  const leadingSlash = pathname[0] == \"/\";\n  pathname = new URL(\n    !leadingSlash ? \"/-\" + pathname : pathname,\n    \"https://example.com\"\n  ).pathname;\n  if (!leadingSlash) {\n    pathname = pathname.substring(2, pathname.length);\n  }\n  return pathname;\n}\nfunction canonicalizePort(port, protocol, isPattern) {\n  if (defaultPortForProtocol(protocol) === port) {\n    port = \"\";\n  }\n  if (isPattern || port === \"\") {\n    return port;\n  }\n  return portEncodeCallback(port);\n}\nfunction canonicalizeProtocol(protocol, isPattern) {\n  protocol = maybeStripSuffix(protocol, \":\");\n  if (isPattern || protocol === \"\") {\n    return protocol;\n  }\n  return protocolEncodeCallback(protocol);\n}\nfunction defaultPortForProtocol(protocol) {\n  switch (protocol) {\n    case \"ws\":\n    case \"http\":\n      return \"80\";\n    case \"wws\":\n    case \"https\":\n      return \"443\";\n    case \"ftp\":\n      return \"21\";\n    default:\n      return \"\";\n  }\n}\nfunction protocolEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[-+.A-Za-z0-9]*$/.test(input))\n    return input.toLowerCase();\n  throw new TypeError(`Invalid protocol '${input}'.`);\n}\nfunction usernameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = input;\n  return url.username;\n}\nfunction passwordEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = input;\n  return url.password;\n}\nfunction hostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(input)) {\n    throw new TypeError(`Invalid hostname '${input}'`);\n  }\n  const url = new URL(\"https://example.com\");\n  url.hostname = input;\n  return url.hostname;\n}\nfunction ipv6HostnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/[^0-9a-fA-F[\\]:]/g.test(input)) {\n    throw new TypeError(`Invalid IPv6 hostname '${input}'`);\n  }\n  return input.toLowerCase();\n}\nfunction portEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  if (/^[0-9]*$/.test(input) && parseInt(input) <= 65535) {\n    return input;\n  }\n  throw new TypeError(`Invalid port '${input}'.`);\n}\nfunction standardURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.pathname = input[0] !== \"/\" ? \"/-\" + input : input;\n  if (input[0] !== \"/\") {\n    return url.pathname.substring(2, url.pathname.length);\n  }\n  return url.pathname;\n}\nfunction pathURLPathnameEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(`data:${input}`);\n  return url.pathname;\n}\nfunction searchEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = input;\n  return url.search.substring(1, url.search.length);\n}\nfunction hashEncodeCallback(input) {\n  if (input === \"\") {\n    return input;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = input;\n  return url.hash.substring(1, url.hash.length);\n}\n\n// src/url-pattern-parser.ts\nvar Parser = class {\n  constructor(input) {\n    this.tokenList = [];\n    this.internalResult = {};\n    this.tokenIndex = 0;\n    this.tokenIncrement = 1;\n    this.componentStart = 0;\n    this.state = 0 /* INIT */;\n    this.groupDepth = 0;\n    this.hostnameIPv6BracketDepth = 0;\n    this.shouldTreatAsStandardURL = false;\n    this.input = input;\n  }\n  get result() {\n    return this.internalResult;\n  }\n  parse() {\n    this.tokenList = lexer(this.input, true);\n    for (; this.tokenIndex < this.tokenList.length; this.tokenIndex += this.tokenIncrement) {\n      this.tokenIncrement = 1;\n      if (this.tokenList[this.tokenIndex].type === \"END\") {\n        if (this.state === 0 /* INIT */) {\n          this.rewind();\n          if (this.isHashPrefix()) {\n            this.changeState(9 /* HASH */, 1);\n          } else if (this.isSearchPrefix()) {\n            this.changeState(8 /* SEARCH */, 1);\n            this.internalResult.hash = \"\";\n          } else {\n            this.changeState(7 /* PATHNAME */, 0);\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n          }\n          continue;\n        } else if (this.state === 2 /* AUTHORITY */) {\n          this.rewindAndSetState(5 /* HOSTNAME */);\n          continue;\n        }\n        this.changeState(10 /* DONE */, 0);\n        break;\n      }\n      if (this.groupDepth > 0) {\n        if (this.isGroupClose()) {\n          this.groupDepth -= 1;\n        } else {\n          continue;\n        }\n      }\n      if (this.isGroupOpen()) {\n        this.groupDepth += 1;\n        continue;\n      }\n      switch (this.state) {\n        case 0 /* INIT */:\n          if (this.isProtocolSuffix()) {\n            this.internalResult.username = \"\";\n            this.internalResult.password = \"\";\n            this.internalResult.hostname = \"\";\n            this.internalResult.port = \"\";\n            this.internalResult.pathname = \"\";\n            this.internalResult.search = \"\";\n            this.internalResult.hash = \"\";\n            this.rewindAndSetState(1 /* PROTOCOL */);\n          }\n          break;\n        case 1 /* PROTOCOL */:\n          if (this.isProtocolSuffix()) {\n            this.computeShouldTreatAsStandardURL();\n            let nextState = 7 /* PATHNAME */;\n            let skip = 1;\n            if (this.shouldTreatAsStandardURL) {\n              this.internalResult.pathname = \"/\";\n            }\n            if (this.nextIsAuthoritySlashes()) {\n              nextState = 2 /* AUTHORITY */;\n              skip = 3;\n            } else if (this.shouldTreatAsStandardURL) {\n              nextState = 2 /* AUTHORITY */;\n            }\n            this.changeState(nextState, skip);\n          }\n          break;\n        case 2 /* AUTHORITY */:\n          if (this.isIdentityTerminator()) {\n            this.rewindAndSetState(3 /* USERNAME */);\n          } else if (this.isPathnameStart() || this.isSearchPrefix() || this.isHashPrefix()) {\n            this.rewindAndSetState(5 /* HOSTNAME */);\n          }\n          break;\n        case 3 /* USERNAME */:\n          if (this.isPasswordPrefix()) {\n            this.changeState(4 /* PASSWORD */, 1);\n          } else if (this.isIdentityTerminator()) {\n            this.changeState(5 /* HOSTNAME */, 1);\n          }\n          break;\n        case 4 /* PASSWORD */:\n          if (this.isIdentityTerminator()) {\n            this.changeState(5 /* HOSTNAME */, 1);\n          }\n          break;\n        case 5 /* HOSTNAME */:\n          if (this.isIPv6Open()) {\n            this.hostnameIPv6BracketDepth += 1;\n          } else if (this.isIPv6Close()) {\n            this.hostnameIPv6BracketDepth -= 1;\n          }\n          if (this.isPortPrefix() && !this.hostnameIPv6BracketDepth) {\n            this.changeState(6 /* PORT */, 1);\n          } else if (this.isPathnameStart()) {\n            this.changeState(7 /* PATHNAME */, 0);\n          } else if (this.isSearchPrefix()) {\n            this.changeState(8 /* SEARCH */, 1);\n          } else if (this.isHashPrefix()) {\n            this.changeState(9 /* HASH */, 1);\n          }\n          break;\n        case 6 /* PORT */:\n          if (this.isPathnameStart()) {\n            this.changeState(7 /* PATHNAME */, 0);\n          } else if (this.isSearchPrefix()) {\n            this.changeState(8 /* SEARCH */, 1);\n          } else if (this.isHashPrefix()) {\n            this.changeState(9 /* HASH */, 1);\n          }\n          break;\n        case 7 /* PATHNAME */:\n          if (this.isSearchPrefix()) {\n            this.changeState(8 /* SEARCH */, 1);\n          } else if (this.isHashPrefix()) {\n            this.changeState(9 /* HASH */, 1);\n          }\n          break;\n        case 8 /* SEARCH */:\n          if (this.isHashPrefix()) {\n            this.changeState(9 /* HASH */, 1);\n          }\n          break;\n        case 9 /* HASH */:\n          break;\n        case 10 /* DONE */:\n          break;\n      }\n    }\n  }\n  changeState(newState, skip) {\n    switch (this.state) {\n      case 0 /* INIT */:\n        break;\n      case 1 /* PROTOCOL */:\n        this.internalResult.protocol = this.makeComponentString();\n        break;\n      case 2 /* AUTHORITY */:\n        break;\n      case 3 /* USERNAME */:\n        this.internalResult.username = this.makeComponentString();\n        break;\n      case 4 /* PASSWORD */:\n        this.internalResult.password = this.makeComponentString();\n        break;\n      case 5 /* HOSTNAME */:\n        this.internalResult.hostname = this.makeComponentString();\n        break;\n      case 6 /* PORT */:\n        this.internalResult.port = this.makeComponentString();\n        break;\n      case 7 /* PATHNAME */:\n        this.internalResult.pathname = this.makeComponentString();\n        break;\n      case 8 /* SEARCH */:\n        this.internalResult.search = this.makeComponentString();\n        break;\n      case 9 /* HASH */:\n        this.internalResult.hash = this.makeComponentString();\n        break;\n      case 10 /* DONE */:\n        break;\n    }\n    this.changeStateWithoutSettingComponent(newState, skip);\n  }\n  changeStateWithoutSettingComponent(newState, skip) {\n    this.state = newState;\n    this.componentStart = this.tokenIndex + skip;\n    this.tokenIndex += skip;\n    this.tokenIncrement = 0;\n  }\n  rewind() {\n    this.tokenIndex = this.componentStart;\n    this.tokenIncrement = 0;\n  }\n  rewindAndSetState(newState) {\n    this.rewind();\n    this.state = newState;\n  }\n  safeToken(index) {\n    if (index < 0) {\n      index = this.tokenList.length - index;\n    }\n    if (index < this.tokenList.length) {\n      return this.tokenList[index];\n    }\n    return this.tokenList[this.tokenList.length - 1];\n  }\n  isNonSpecialPatternChar(index, value) {\n    const token = this.safeToken(index);\n    return token.value === value && (token.type === \"CHAR\" || token.type === \"ESCAPED_CHAR\" || token.type === \"INVALID_CHAR\");\n  }\n  isProtocolSuffix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  nextIsAuthoritySlashes() {\n    return this.isNonSpecialPatternChar(this.tokenIndex + 1, \"/\") && this.isNonSpecialPatternChar(this.tokenIndex + 2, \"/\");\n  }\n  isIdentityTerminator() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"@\");\n  }\n  isPasswordPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPortPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \":\");\n  }\n  isPathnameStart() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"/\");\n  }\n  isSearchPrefix() {\n    if (this.isNonSpecialPatternChar(this.tokenIndex, \"?\")) {\n      return true;\n    }\n    if (this.tokenList[this.tokenIndex].value !== \"?\") {\n      return false;\n    }\n    const previousToken = this.safeToken(this.tokenIndex - 1);\n    return previousToken.type !== \"NAME\" && previousToken.type !== \"PATTERN\" && previousToken.type !== \"CLOSE\" && previousToken.type !== \"ASTERISK\";\n  }\n  isHashPrefix() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"#\");\n  }\n  isGroupOpen() {\n    return this.tokenList[this.tokenIndex].type == \"OPEN\";\n  }\n  isGroupClose() {\n    return this.tokenList[this.tokenIndex].type == \"CLOSE\";\n  }\n  isIPv6Open() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"[\");\n  }\n  isIPv6Close() {\n    return this.isNonSpecialPatternChar(this.tokenIndex, \"]\");\n  }\n  makeComponentString() {\n    const token = this.tokenList[this.tokenIndex];\n    const componentCharStart = this.safeToken(this.componentStart).index;\n    return this.input.substring(componentCharStart, token.index);\n  }\n  computeShouldTreatAsStandardURL() {\n    const options = {};\n    Object.assign(options, DEFAULT_OPTIONS);\n    options.encodePart = protocolEncodeCallback;\n    const regexp = pathToRegexp(this.makeComponentString(), void 0, options);\n    this.shouldTreatAsStandardURL = isSpecialScheme(regexp);\n  }\n};\n\n// src/url-pattern.ts\nvar COMPONENTS = [\n  \"protocol\",\n  \"username\",\n  \"password\",\n  \"hostname\",\n  \"port\",\n  \"pathname\",\n  \"search\",\n  \"hash\"\n];\nvar DEFAULT_PATTERN = \"*\";\nfunction extractValues(url, baseURL) {\n  if (typeof url !== \"string\") {\n    throw new TypeError(`parameter 1 is not of type 'string'.`);\n  }\n  const o = new URL(url, baseURL);\n  return {\n    protocol: o.protocol.substring(0, o.protocol.length - 1),\n    username: o.username,\n    password: o.password,\n    hostname: o.hostname,\n    port: o.port,\n    pathname: o.pathname,\n    search: o.search != \"\" ? o.search.substring(1, o.search.length) : void 0,\n    hash: o.hash != \"\" ? o.hash.substring(1, o.hash.length) : void 0\n  };\n}\nfunction processBaseURLString(input, isPattern) {\n  if (!isPattern) {\n    return input;\n  }\n  return escapePatternString(input);\n}\nfunction applyInit(o, init, isPattern) {\n  let baseURL;\n  if (typeof init.baseURL === \"string\") {\n    try {\n      baseURL = new URL(init.baseURL);\n      o.protocol = processBaseURLString(baseURL.protocol.substring(0, baseURL.protocol.length - 1), isPattern);\n      o.username = processBaseURLString(baseURL.username, isPattern);\n      o.password = processBaseURLString(baseURL.password, isPattern);\n      o.hostname = processBaseURLString(baseURL.hostname, isPattern);\n      o.port = processBaseURLString(baseURL.port, isPattern);\n      o.pathname = processBaseURLString(baseURL.pathname, isPattern);\n      o.search = processBaseURLString(baseURL.search.substring(1, baseURL.search.length), isPattern);\n      o.hash = processBaseURLString(baseURL.hash.substring(1, baseURL.hash.length), isPattern);\n    } catch {\n      throw new TypeError(`invalid baseURL '${init.baseURL}'.`);\n    }\n  }\n  if (typeof init.protocol === \"string\") {\n    o.protocol = canonicalizeProtocol(init.protocol, isPattern);\n  }\n  if (typeof init.username === \"string\") {\n    o.username = canonicalizeUsername(init.username, isPattern);\n  }\n  if (typeof init.password === \"string\") {\n    o.password = canonicalizePassword(init.password, isPattern);\n  }\n  if (typeof init.hostname === \"string\") {\n    o.hostname = canonicalizeHostname(init.hostname, isPattern);\n  }\n  if (typeof init.port === \"string\") {\n    o.port = canonicalizePort(init.port, o.protocol, isPattern);\n  }\n  if (typeof init.pathname === \"string\") {\n    o.pathname = init.pathname;\n    if (baseURL && !isAbsolutePathname(o.pathname, isPattern)) {\n      const slashIndex = baseURL.pathname.lastIndexOf(\"/\");\n      if (slashIndex >= 0) {\n        o.pathname = processBaseURLString(baseURL.pathname.substring(0, slashIndex + 1), isPattern) + o.pathname;\n      }\n    }\n    o.pathname = canonicalizePathname(o.pathname, o.protocol, isPattern);\n  }\n  if (typeof init.search === \"string\") {\n    o.search = canonicalizeSearch(init.search, isPattern);\n  }\n  if (typeof init.hash === \"string\") {\n    o.hash = canonicalizeHash(init.hash, isPattern);\n  }\n  return o;\n}\nfunction escapePatternString(value) {\n  return value.replace(/([+*?:{}()\\\\])/g, \"\\\\$1\");\n}\nfunction escapeRegexpString(value) {\n  return value.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\nfunction tokensToPattern(tokens, options) {\n  const wildcardPattern = \".*\";\n  const segmentWildcardPattern = `[^${escapeRegexpString(options.delimiter === void 0 ? \"/#?\" : options.delimiter)}]+?`;\n  const regexIdentifierPart2 = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n  let result = \"\";\n  for (let i = 0; i < tokens.length; ++i) {\n    const token = tokens[i];\n    const lastToken = i > 0 ? tokens[i - 1] : null;\n    const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;\n    if (typeof token === \"string\") {\n      result += escapePatternString(token);\n      continue;\n    }\n    if (token.pattern === \"\") {\n      if (token.modifier === \"\") {\n        result += escapePatternString(token.prefix);\n        continue;\n      }\n      result += `{${escapePatternString(token.prefix)}}${token.modifier}`;\n      continue;\n    }\n    const customName = typeof token.name !== \"number\";\n    const optionsPrefixes = options.prefixes !== void 0 ? options.prefixes : \"./\";\n    let needsGrouping = token.suffix !== \"\" || token.prefix !== \"\" && (token.prefix.length !== 1 || !optionsPrefixes.includes(token.prefix));\n    if (!needsGrouping && customName && token.pattern === segmentWildcardPattern && token.modifier === \"\" && nextToken && !nextToken.prefix && !nextToken.suffix) {\n      if (typeof nextToken === \"string\") {\n        const code = nextToken.length > 0 ? nextToken[0] : \"\";\n        needsGrouping = regexIdentifierPart2.test(code);\n      } else {\n        needsGrouping = typeof nextToken.name === \"number\";\n      }\n    }\n    if (!needsGrouping && token.prefix === \"\" && lastToken && typeof lastToken === \"string\" && lastToken.length > 0) {\n      const code = lastToken[lastToken.length - 1];\n      needsGrouping = optionsPrefixes.includes(code);\n    }\n    if (needsGrouping) {\n      result += \"{\";\n    }\n    result += escapePatternString(token.prefix);\n    if (customName) {\n      result += `:${token.name}`;\n    }\n    if (token.pattern === wildcardPattern) {\n      if (!customName && (!lastToken || typeof lastToken === \"string\" || lastToken.modifier || needsGrouping || token.prefix !== \"\")) {\n        result += \"*\";\n      } else {\n        result += `(${wildcardPattern})`;\n      }\n    } else if (token.pattern === segmentWildcardPattern) {\n      if (!customName) {\n        result += `(${segmentWildcardPattern})`;\n      }\n    } else {\n      result += `(${token.pattern})`;\n    }\n    if (token.pattern === segmentWildcardPattern && customName && token.suffix !== \"\") {\n      if (regexIdentifierPart2.test(token.suffix[0])) {\n        result += \"\\\\\";\n      }\n    }\n    result += escapePatternString(token.suffix);\n    if (needsGrouping) {\n      result += \"}\";\n    }\n    result += token.modifier;\n  }\n  return result;\n}\nvar URLPattern = class {\n  constructor(init = {}, baseURLOrOptions, options) {\n    this.regexp = {};\n    this.keys = {};\n    this.component_pattern = {};\n    try {\n      let baseURL = void 0;\n      if (typeof baseURLOrOptions === \"string\") {\n        baseURL = baseURLOrOptions;\n      } else {\n        options = baseURLOrOptions;\n      }\n      if (typeof init === \"string\") {\n        const parser = new Parser(init);\n        parser.parse();\n        init = parser.result;\n        if (baseURL === void 0 && typeof init.protocol !== \"string\") {\n          throw new TypeError(`A base URL must be provided for a relative constructor string.`);\n        }\n        init.baseURL = baseURL;\n      } else {\n        if (!init || typeof init !== \"object\") {\n          throw new TypeError(`parameter 1 is not of type 'string' and cannot convert to dictionary.`);\n        }\n        if (baseURL) {\n          throw new TypeError(`parameter 1 is not of type 'string'.`);\n        }\n      }\n      if (typeof options === \"undefined\") {\n        options = { ignoreCase: false };\n      }\n      const ignoreCaseOptions = { ignoreCase: options.ignoreCase === true };\n      const defaults = {\n        pathname: DEFAULT_PATTERN,\n        protocol: DEFAULT_PATTERN,\n        username: DEFAULT_PATTERN,\n        password: DEFAULT_PATTERN,\n        hostname: DEFAULT_PATTERN,\n        port: DEFAULT_PATTERN,\n        search: DEFAULT_PATTERN,\n        hash: DEFAULT_PATTERN\n      };\n      this.pattern = applyInit(defaults, init, true);\n      if (defaultPortForProtocol(this.pattern.protocol) === this.pattern.port) {\n        this.pattern.port = \"\";\n      }\n      let component;\n      for (component of COMPONENTS) {\n        if (!(component in this.pattern))\n          continue;\n        const options2 = {};\n        const pattern = this.pattern[component];\n        this.keys[component] = [];\n        switch (component) {\n          case \"protocol\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = protocolEncodeCallback;\n            break;\n          case \"username\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = usernameEncodeCallback;\n            break;\n          case \"password\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = passwordEncodeCallback;\n            break;\n          case \"hostname\":\n            Object.assign(options2, HOSTNAME_OPTIONS);\n            if (treatAsIPv6Hostname(pattern)) {\n              options2.encodePart = ipv6HostnameEncodeCallback;\n            } else {\n              options2.encodePart = hostnameEncodeCallback;\n            }\n            break;\n          case \"port\":\n            Object.assign(options2, DEFAULT_OPTIONS);\n            options2.encodePart = portEncodeCallback;\n            break;\n          case \"pathname\":\n            if (isSpecialScheme(this.regexp.protocol)) {\n              Object.assign(options2, PATHNAME_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = standardURLPathnameEncodeCallback;\n            } else {\n              Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n              options2.encodePart = pathURLPathnameEncodeCallback;\n            }\n            break;\n          case \"search\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = searchEncodeCallback;\n            break;\n          case \"hash\":\n            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);\n            options2.encodePart = hashEncodeCallback;\n            break;\n        }\n        try {\n          const tokens = parse(pattern, options2);\n          this.regexp[component] = tokensToRegexp(tokens, this.keys[component], options2);\n          this.component_pattern[component] = tokensToPattern(tokens, options2);\n        } catch {\n          throw new TypeError(`invalid ${component} pattern '${this.pattern[component]}'.`);\n        }\n      }\n    } catch (err) {\n      throw new TypeError(`Failed to construct 'URLPattern': ${err.message}`);\n    }\n  }\n  test(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return false;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return false;\n    }\n    let component;\n    for (component of COMPONENTS) {\n      if (!this.regexp[component].exec(values[component])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  exec(input = {}, baseURL) {\n    let values = {\n      pathname: \"\",\n      protocol: \"\",\n      username: \"\",\n      password: \"\",\n      hostname: \"\",\n      port: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n    if (typeof input !== \"string\" && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n    if (typeof input === \"undefined\") {\n      return;\n    }\n    try {\n      if (typeof input === \"object\") {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err) {\n      return null;\n    }\n    let result = {};\n    if (baseURL) {\n      result.inputs = [input, baseURL];\n    } else {\n      result.inputs = [input];\n    }\n    let component;\n    for (component of COMPONENTS) {\n      let match = this.regexp[component].exec(values[component]);\n      if (!match) {\n        return null;\n      }\n      let groups = {};\n      for (let [i, key] of this.keys[component].entries()) {\n        if (typeof key.name === \"string\" || typeof key.name === \"number\") {\n          let value = match[i + 1];\n          groups[key.name] = value;\n        }\n      }\n      result[component] = {\n        input: values[component] || \"\",\n        groups\n      };\n    }\n    return result;\n  }\n  get protocol() {\n    return this.component_pattern.protocol;\n  }\n  get username() {\n    return this.component_pattern.username;\n  }\n  get password() {\n    return this.component_pattern.password;\n  }\n  get hostname() {\n    return this.component_pattern.hostname;\n  }\n  get port() {\n    return this.component_pattern.port;\n  }\n  get pathname() {\n    return this.component_pattern.pathname;\n  }\n  get search() {\n    return this.component_pattern.search;\n  }\n  get hash() {\n    return this.component_pattern.hash;\n  }\n};\nexport {\n  URLPattern\n};\n","import { URLPattern } from \"./dist/urlpattern.js\";\n\nexport { URLPattern };\n\nif (!globalThis.URLPattern) {\n  globalThis.URLPattern = URLPattern;\n}\n"],"names":["regexIdentifierStart","regexIdentifierPart","isASCII","str","extended","lexer","lenient","tokens","i","char","ErrorOrInvalid","msg","name","j","code","count","pattern","error","parse","options","prefixes","defaultPattern","escapeString","result","key","path","nameSet","tryConsume","type","tryConsumeModifier","r","mustConsume","value","nextType","index","consumeText","result2","DefaultEncodePart","encodePart","prefix","finalName","name2","pattern2","suffix","modifier","flags","regexpToRegexp","keys","groupsRegex","execResult","arrayToRegexp","paths","parts","pathToRegexp","stringToRegexp","tokensToRegexp","strict","start","end","encode","x","endsWith","delimiter","route","token","mod","endToken","isEndDelimited","DEFAULT_OPTIONS","HOSTNAME_OPTIONS","PATHNAME_OPTIONS","isAbsolutePathname","pathname","isPattern","maybeStripPrefix","maybeStripSuffix","treatAsIPv6Hostname","SPECIAL_SCHEMES","isSpecialScheme","protocol_regexp","scheme","canonicalizeHash","hash","url","canonicalizeSearch","search","canonicalizeHostname","hostname","ipv6HostnameEncodeCallback","hostnameEncodeCallback","canonicalizePassword","password","canonicalizeUsername","username","canonicalizePathname","protocol","leadingSlash","canonicalizePort","port","defaultPortForProtocol","portEncodeCallback","canonicalizeProtocol","protocolEncodeCallback","input","usernameEncodeCallback","passwordEncodeCallback","standardURLPathnameEncodeCallback","pathURLPathnameEncodeCallback","searchEncodeCallback","hashEncodeCallback","Parser","nextState","skip","newState","previousToken","componentCharStart","regexp","COMPONENTS","DEFAULT_PATTERN","extractValues","baseURL","o","processBaseURLString","escapePatternString","applyInit","init","slashIndex","escapeRegexpString","tokensToPattern","wildcardPattern","segmentWildcardPattern","regexIdentifierPart2","lastToken","nextToken","customName","optionsPrefixes","needsGrouping","URLPattern","baseURLOrOptions","parser","ignoreCaseOptions","defaults","component","options2","err","values","match","groups"],"mappings":"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","x_google_ignoreList":[0,1]}